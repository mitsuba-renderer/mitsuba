<?xml version="1.0"?>
<documentation version="2.0.2">
	<plugin type="scene" className="Scene">
		<shortDescr>Scene root element</shortDescr>
		<descr>Tweaking the kd-tree construction parameters is generally not required.</descr>
		<param name="kdClip" type="boolean" default="true">kd-tree construction: Enable primitive clipping? Generally leads to a significant improvement of the resulting tree.</param>
		<param name="kdIntersectionCost" type="float" default="20">kd-tree construction: Relative cost of a triangle intersection operation in the surface area heuristic.</param>
		<param name="kdTraversalCost" type="float" default="15">kd-tree construction: Relative cost of a kd-tree traversal operation in the surface area heuristic.</param>
		<param name="kdEmptyBonus" type="float" default="0.8">kd-tree construction: Bonus factor for cutting away regions of empty space</param>
		<param name="kdStopPrims" type="integer" default="8">kd-tree construction: A kd-tree node containing this many or fewer primitives will not be split</param>
		<child type="integrator" count="1">Requires an integrator</child>
		<child type="camera" count="1">Requires a camera</child>
		<child type="luminaire" count="+">Requires one or more luminaires</child>
		<child type="shape" count="+">Requires one or more shapes</child>
	</plugin>

	<plugin type="integrator" className="SampleIntegrator" abstract="true">
		<shortDescr>Base class of all sampling-based integrators</shortDescr>
		<descr>Base class of all sampling-based integrators</descr>
	</plugin>

	<plugin type="integrator" className="MonteCarloIntegrator" abstract="true" extends="SampleIntegrator">
		<shortDescr>Base class of recursive MC integrators</shortDescr>
		<descr>
			Base class of all recursive Monte Carlo integrators, which compute
			unbiased solutions to the rendering equation (and optionally
			the radiative transfer equation).
		 </descr>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
			Specifies the longest path depth in the generated output image (where <tt>-1</tt>
			corresponds to ∞). A value of 1 will only render directly visible light sources. 
			2 will lead to single-bounce (direct-only) illumination, and so on.
		</param>
		<param name="rrDepth" readableName="Russian Roulette starting depth" type="integer" default="5" importance="1">
			Specifies the minimum path depth, after which the implementation will start to use the 
			"russian roulette" path termination criterion (set to <tt>-1</tt> to disable). 
		</param>
		<param name="strictNormals" readableName="Strict surface normals" type="boolean" default="false" importance="1">
			<p>
			This parameter specifies the action to be taken when the geometric
			and shading normals of a surface don't agree on whether a ray is on
			the front or back-side of a surface.
			</p>
			<p>
			When <tt>strictNormals</tt> is set to <tt>false</tt>, the shading normal has 
			precedence, and rendering proceeds normally at the risk of
			introducing small light leaks (this is the default).
			</p>
			<p>
			When <tt>strictNormals</tt> is set to <tt>true</tt>, the random walk is
			terminated when encountering such a situation. This may
			produce silhouette darkening on badly tesselated meshes.
			</p>
		</param>
	</plugin>

	<plugin type="integrator" name="irrcache" readableName="Irradiance cache"
		    className="IrradianceCacheIntegrator">
		<descr>
			<p>Irradiance caching integrator - forwards all radiance computations 
			to an arbitrary nested sampling-based integrator - with one exception:
			whenever a Lambertian surface is intersected, an internal irradiance
			cache is queried for the indirect illumination at the surface position in 
			question. If this query is successful, the sub-integrator is only 
			used to compute the remaining types of radiance (direct, in-scatter, 
			emission) and their sum is returned afterwards.
			When a query is unsuccessful, a new data point is generated by a final
			gathering step.</p>

			<p>The generality of this implementation allows it to be used in conjunction
			with photon mapping (the most likely application) as well as all other 
			sampling-based integrators in Mitsuba. Several optimizations are used to
			improve the achieved interpolation quality, namely irradiance gradients 
			[Ward et al.], neighbor clamping [Krivanek et al.], a screen-space 
			clamping metric and an improved error function [Tabellion et al.].
			By default, this integrator also performs a distributed overture pass before
			rendering, which is recommended to avoid artifacts resulting from the
			addition of samples as rendering proceeds.</p>
		</descr>
		<param name="resolution" readableName="Final Gather resolution" type="integer" default="14">
		   Elevational resolution of the stratified final gather hemisphere.
		   The azimuthal resolution is three times this value. Default: <tt>14</tt>, which
		   leads to <tt>14x(2*14)=392</tt> samples 
		</param>
		<param name="quality" readableName="Quality" type="float" default="1">
		   Quality setting (\kappa in the [Tabellion et al.] paper).
		   A value of 1 should be adequate in most cases.
		</param>
		<param name="gradients" readableName="Irradiance gradients" type="boolean" default="true">
		   Should irradiance gradients be used? Generally, this will
		   significantly improve the interpolation quality.
		</param>
		<param name="clampNeighbor" readableName="Neighbor clamping" type="boolean" default="true">
		   Should neighbor clamping [Krivanek et al.] be used? This 
		   propagates geometry information amongst close-by samples 
		   and generally leads to better sample placement. 
		</param>
		<param name="clampScreen" readableName="Screen-space clamping" type="boolean" default="true">
		   If set to true, the influence region of samples will be clamped
		   using the screen-space metric by [Tabellion et al.]? 
		   Turning this off may lead to excessive sample placement.
		</param>
		<param name="overture" readableName="Overture pass" type="boolean" default="true">
		   If set to true, the irradiance cache will be filled by a
		   parallel overture pass before the main rendering process starts.
		   This is strongly recommended.
		</param>
		<param name="qualityAdjustment" readableName="Quality adjustment" type="float" default=".5">
		   Multiplicative factor for the quality parameter following an
		   overture pass. This can be used to interpolate amongst more
		   samples, creating a visually smoother result. Must be
		   1 or less. 
		</param>
		<param name="indirectOnly" readableName="Show indirect illumination only" type="boolean" default="false">
		   If set to true, direct illumination will be suppressed - 
		   useful for checking the interpolation quality
		</param>
		<param name="debug" readableName="Visualize sample placement" type="boolean" default="false">
			If set to true, sample locations are visually highlighted as they are generated.
			This is useful for checking the quality of their placement.
		</param>
		<child type="integrator" count="1" extends="SampleIntegrator">Requires a sampling-based sub-integrator</child>
	</plugin>

	<plugin type="integrator" name="adaptive" readableName="Adaptive integrator"
		    className="AdaptiveIntegrator">
		<descr>
			Adaptive integrator - runs a secondary integrator until the 
			the computed radiance achieves a specifiable relative error 
			threshold (5% by default) with a certain probability (95% by default). 
			Internally, it uses a Z-test to decide when to stop collecting samples.
			While not entirely rigorous in the statistical sense, this provides a 
			useful stopping criterion. 
		</descr>
		<param name="maxError" readableName="Maximum relative error" type="float" default="0.05">Maximum relative error threshold</param>
		<param name="maxSampleFactor" readableName="Maximum number of samples" type="integer" default="32">
			Maximum number of samples to be generated <em>relative</em> to the number of configured pixel samples. The adaptive integrator
			will stop after this many samples, regardless of whether or not the error criterion was satisfied. A negative value will be 
			interpreted as ∞.
		</param>
		<param name="pValue" readableName="Required P-value" type="float" default="0.05" importance="1">Required P-value to accept a sample.</param>
		<child type="integrator" count="1" extends="SampleIntegrator">Requires a sampling-based sub-integrator</child>
	</plugin>

	<plugin type="integrator" name="ao" readableName="Ambient occlusion"
			show="true" className="AmbientOcclusionIntegrator" extends="SampleIntegrator">
		<descr>
			Ambient Occlusion is a non-photorealistic rendering technique that simulates the exposure of an object
			to uniform illumination incident from all direction. It produces approximate shadowing between closeby
			objects, as well as darkening in corners, creases, and cracks.
		</descr>
		<param name="shadingSamples" readableName="Shading samples" type="integer" default="1">
			Specifies the number of shading samples that should be computed per primary ray
		</param>
		<param name="rayLength" readableName="Occlusion ray length" type="float" default="-1">
			Specifies the world-space length of the ambient occlusion rays that will be cast. Default: -1, i.e. automatic
		</param>
	</plugin>

	<plugin type="integrator" name="direct" readableName="Direct illumination"
			show="true" className="MIDirectIntegrator" extends="SampleIntegrator">
		<descr>
			Direct-only integrator using multiple importance sampling.
			Takes a user-specifiable amount of luminaire
			and BSDF samples and combines them using the power heuristic
			By setting one of the strategies to zero, this 
			plugin can effectively be turned into a luminaire sampling or
			BSDF sampling-based integrator. Ignores participating media
			if they are present.
		</descr>
		<param name="emitterSamples" readableName="Emitter samples" type="integer" default="1">Number of samples to take using the emitter sampling technique</param>
		<param name="bsdfSamples" readableName="BSDF samples" type="integer" default="1">Number of samples to take using the BSDF sampling technique</param>
		<param name="strictNormals" readableName="Strict surface normals" type="boolean" default="false" importance="1">
			<p>
			This parameter specifies the action to be taken when the geometric
			and shading normals of a surface don't agree on whether a ray is on
			the front or back-side of a surface.
			</p>
			<p>
			When <tt>strictNormals</tt> is set to <tt>false</tt>, the shading normal has 
			precedence, and rendering proceeds normally at the risk of
			introducing small light leaks (this is the default).
			</p>
			<p>
			When <tt>strictNormals</tt> is set to <tt>true</tt>, the random walk is
			terminated when encountering such a situation. This may
			produce silhouette darkening on badly tesselated meshes.
			</p>
		</param>
	</plugin>

	<plugin type="integrator" name="path" readableName="Path tracer"
			show="true" className="MIPathTracer" extends="MonteCarloIntegrator">
		<descr>
			Extended path tracer -- uses multiple importance sampling to combine 
			two sampling strategies, namely BSDF and luminaire sampling. This class also
			supports volumetric absorption, but does not attempt to solve the
			full radiative transfer equation (see <tt>volpath</tt> if this is needed).
		</descr>
	</plugin>
 
	<plugin type="integrator" name="volpath_simple" readableName = "Volumetric path tracer (Simple)"
			show="true" className="SimpleVolumetricPathTracer" extends="MonteCarloIntegrator">
		<descr>
			Volumetric path tracer, which solves the full radiative transfer
			equation in the presence of participating media. 
			Simplified version without multiple importance sampling - this 
			version can be significantly faster than the extended
			version when when rendering heterogeneous participating media using the 
			[Coleman et al.] sampling technique, as fewer attenuation
			evaluations will be performed.
		</descr>
	</plugin>

	<plugin type="integrator" name="volpath" readableName = "Volumetric path tracer (Extended)"
			show="true" className="VolumetricPathTracer" extends="MonteCarloIntegrator">
		<descr>
			Volumetric path tracer, which solves the full radiative transfer
			equation in the presence of participating media. Estimates single
			scattering using both phase function and luminaire sampling and
			combines the two with multiple importance sampling and the power
			heuristic. Afterwards, the phase function sample is reused to
			recursively estimate the multiple scattering component, which saves an
			intersection computation.
			On surfaces, this integrator behaves exactly like the MI path tracer.
		</descr>
	</plugin>

	<plugin type="integrator" name="ptracer" readableName="Adjoint particle tracer" show="true"
			className="ParticleTracer" extends="ImageBasedIntegrator">
	<descr>
			<p>This plugin implements a simple adjoint particle tracer. It does 
			essentially the exact opposite of the simple volumetric path tracer:
			instead of tracing rays from the sensor
			and attempting to connect them to the light source, this integrator
			shoots particles from the light source and attempts to connect them to
			the sensor.</p>

			<p>Usually, this is a relatively useless rendering technique due to
			its high variance, but there are some cases where it excels.
			In particular, it does a good job on scenes where most scattering 
			events are directly visible to the camera.</p>

			<p>When rendering with a finite-aperture sensor 
			this integrator is able to intersect the actual aperture, which allows it to 
			handle certain caustic paths that would otherwise not be visible.</p>

			<p>It also supports a specialized "brute force" mode, where the integrator
			does not attempt to create connections to the sensor and purely relies on
			hitting it via ray tracing. This is one of the worst conceivable rendering
			and not recommended for any applications. It is mainly included for 
			debugging purposes.</p>
		 </descr>
		<param name="granularity" readableName="Work unit granularity" type="integer" default="200000" importance="1">
			Specifies the work unit granularity used to parallize the
			the particle tracing task (default: 200K samples per work unit).
			This should be high enough so that accumulating
			partially exposed images (and potentially sending them over the
			network) is not the bottleneck.
		</param>
		<param name="rrDepth" readableName="Russian Roulette starting depth" type="integer" default="5" importance="1">
			Specifies the minimum path depth, after which the implementation will start to use the 
			"russian roulette" path termination criterion (set to <tt>-1</tt> to disable). 
		</param>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
			Specifies the longest path depth in the generated output image (where <tt>-1</tt>
			corresponds to ∞). A value of 1 will only render directly visible light sources. 
			2 will lead to single-bounce (direct-only) illumination, and so on.
		</param>
		<param name="bruteForce" readableName="Brute force" type="boolean" default="false">
			If set to <tt>true</tt> the integrator does not attempt to create
			connections to the sensor and purely relies on hitting it via ray
			tracing. This is mainly intended for debugging purposes.
		</param>
	</plugin>

	<plugin type="integrator" name="vpl" readableName = "Virtual point light renderer"
			show="true" className="VPLIntegrator" extends="Integrator">
		<descr>
			Rasterization-based global illuminated technique using hardware
			accelerated renderings of the scene under point source illumination. Based on 
			"Instant Radiosity" by Alexander Keller in Computer Graphics Proceedings, 
			Annual Conference Series, SIGGRAPH 97, pp. 49-56. 
		</descr>
		<param name="vplCount" readableName="Number of VPLs" type="integer" default="1000">Total number of virtual point lights that should be rendered</param>
		<param name="shadowMapResolution" readableName="Shadow Map Resolution" type="integer" default="512">Shadow map resolution</param>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
			Longest visualized path length (<tt>-1</tt>=infinite). When a positive value is
			specified, it must be greater or equal to <tt>2</tt>, which corresponds to single-bounce
			(direct-only) illumination.
		</param>
		<param name="clamping" readableName="Clamping factor" type="float" default="0.1">Relative clamping factor (0=no clamping, 1=full clamping)</param>
	</plugin>

	<plugin type="integrator" name="photonmapper" readableName="Photon mapper" show="true"
			className="PhotonMapIntegrator" extends="SampleIntegrator">
		<descr>
				<p>This plugin implements the two-pass photon mapping algorithm as proposed by Jensen.
				The implementation partitions the illumination into three different classes (diffuse, caustic, and volumetric),
				and builds a separate photon map for each class.</p>

				<p>Following this, a standard recursive ray tracing pass is started which performs kernel density estimation
				using these photon maps. Since the photon maps are visualized directly, the result will appear "blotchy"
				unless an extremely large number of photons is used. A simple remedy is to combine the photon mapper with
				an irradiance cache, which performs <em>final gathering</em> to remove these artifacts. Due to its caching nature,
				the rendering process will be faster as well.</p>
		</descr>
		<param name="directSamples" readableName="Direct samples" type="integer" default="16">Number of luminaire samples for direct illumination</param>
		<param name="glossySamples" readableName="Glossy samples" type="integer" default="32">Number of glossy samples for direct illumination</param>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
			Specifies the longest path depth in the generated output image (where <tt>-1</tt>
			corresponds to ∞). A value of 1 will only render directly visible light sources. 
			2 will lead to single-bounce (direct-only) illumination, and so on.
		</param>
		<param name="globalPhotons" readableName="Global photons" type="integer" default="250000">Number of photons to collect for the global photon map (if applicable)</param>
		<param name="causticPhotons" readableName="Caustic photons" type="integer" default="250000">Number of photons to collect for the caustic photon map (if applicable)</param>
		<param name="volumePhotons" readableName="Volume photons" type="integer" default="250000">Number of photons to collect for the volume photon map (if applicable)</param>
		<param name="globalLookupRadius" readableName="Lookup radius (global)" type="float" default="0.05">Radius of lookups in the global photon map (relative to the scene size)</param>
		<param name="causticLookupRadius" readableName="Lookup radius (caustic)" type="float" default="0.0125">Radius of lookups in the caustic photon map (relative to the scene size)</param>
		<param name="lookupSize" readableName="Caustic photon map lookup size" type="integer" default="120">Number of photons that should be fetched in photon map queries</param>
		<param name="granularity" readableName="Work unit granularity" importance="1" type="integer" default="0">Granularity of photon tracing work units (in shot particles, 0 => decide automatically)</param>
		<param name="rrDepth" readableName="Russian Roulette starting depth" type="integer" default="5" importance="1">
			Specifies the minimum path depth, after which the implementation will start to use the 
			"russian roulette" path termination criterion when tracing photons (set to <tt>-1</tt> to disable). 
		</param>
	</plugin>

	<plugin type="integrator" name="ppm" readableName="Progressive photon mapper"
			show="true" className="ProgressivePhotonMapIntegrator" extends="Integrator">
		<descr>
			 Progressive photon mapping implementation. Only handles surface
			 interactions. Parallelization is limited to the local cores.
		</descr>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
			Longest visualized path length (<tt>-1</tt>=infinite). When a positive value is
			specified, it must be greater or equal to <tt>2</tt>, which corresponds to single-bounce
			(direct-only) illumination.
		</param>
		<param name="initialRadius" readableName="Initial radius" type="float" default="0">Initial photon query radius (0 = infer based on scene size and camera resolution)</param>
		<param name="photonCount" readableName="Photons per iteration" type="integer" default="250000">Number of photons to shoot in each iteration</param>
		<param name="granularity" readableName="Work unit granularity" importance="1" type="integer" default="0">Granularity of photon tracing work units (in shot particles, 0 => decide automatically)</param>
		<param name="rrDepth" readableName="Russian Roulette starting depth" type="integer" default="5" importance="1">
			Specifies the minimum path depth, after which the implementation will start to use the 
			"russian roulette" path termination criterion when tracing photons (set to <tt>-1</tt> to disable). 
		</param>
		<param name="alpha" readableName="Size reduction parameter" type="float" default="0.7" importance="1">Alpha parameter from the paper (influences the speed, at which the photon radius is reduced)</param>
	</plugin>

	<plugin type="integrator" name="sppm" readableName="Stochastic progressive photon mapper"
			show="true" className="StochasticProgressivePhotonMapIntegrator" extends="Integrator">
		<descr>
			 Stochastic progressive photon mapping implementation. Only handles surface
			 interactions. Parallelization is limited to the local cores.
		</descr>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
			Longest visualized path length (<tt>-1</tt>=infinite). When a positive value is
			specified, it must be greater or equal to <tt>2</tt>, which corresponds to single-bounce
			(direct-only) illumination.
		</param>
		<param name="initialRadius" readableName="Initial radius" type="float" default="0">Initial photon query radius (0 = infer based on scene size and camera resolution)</param>
		<param name="photonCount" readableName="Photons per iteration" type="integer" default="250000">Number of photons to shoot in each iteration</param>
		<param name="granularity" readableName="Work unit granularity" importance="1" type="integer" default="0">Granularity of photon tracing work units (in shot particles, 0 => decide automatically)</param>
		<param name="rrDepth" readableName="Russian Roulette starting depth" type="integer" default="5" importance="1">
			Specifies the minimum path depth, after which the implementation will start to use the 
			"russian roulette" path termination criterion (set to <tt>-1</tt> to disable). 
		</param>
		<param name="alpha" readableName="Size reduction parameter" type="float" default="0.7" importance="1">Alpha parameter from the paper (influences the speed, at which the photon radius is reduced)</param>
	</plugin>

	<plugin type="integrator" name="bdpt" readableName="Bidirectional path tracer" show="true"
			className="BidirectionalIntegrator" extends="Integrator">
		<descr>
			<p>This plugin implements a Veach-style bidirectional path tracer (short:
			BDPT) with support for multiple importance sampling.</p>

			<p>A bidirectional path tracer generates a sample by starting two separate
			random walks from an emitter and a sensor. The resulting <em>subpaths</em> are 
			connected at every possible position, creating a large number of complete paths
			of different lengths. These paths are then used to estimate the amount of 
			radiance that is transferred from the emitter to a pixel on the sensor.</p>

			<p>Generally, some of the created paths will be unusable, since they lead to
			high-variance radiance estimates. To alleviate this situation, BDPT makes
			use of <em>multiple importance sampling</em> which, roughly speaking, weights
			paths based on their predicted utility.</p>

			<p>The bidirectional path tracer in Mitsuba is a complete implementation of the
			technique that handles all sampling strategies, including those that involve 
			direct interactions with the sensor. For this purpose, finite-aperture sensors 
			are explicitly represented by surfaces in the scene so that they can be 
			intersected by random walks started at emitters.</p>

			<p>Bidirectional path tracing is a relatively "heavy" rendering technique---for
			the same number of samples per pixel, it is easily 3-4 times slower than regular
			path tracing. However, it usually makes up for this by producing considerably
			lower-variance radiance estimates (i.e. the output images have less noise).</p>

			<p>The code parallelizes over multiple cores and machines, but with one caveat:
			some of the BDPT path sampling strategies are incompatble with the usual
			approach of rendering an image tile by tile, since they can potentially 
			contribute to <em>any</em> pixel on the screen. This means that each
			rendering work unit must be associated with a full-sized image!
			When network render nodes are involved or the resolution of this <em>light image</em>
			is very high, a bottleneck can arise where more work is spent accumulating or 
			transmitting these images than actual rendering.</p>

			<p>There are two possible resorts should this situation arise: the first one
			is to reduce the number of work units so that there is approximately one 
			unit per core (and hence one image to transmit per core). This can be done by 
			increasing the block size in the GUI preferences or passing the <tt>-b</tt> 
			parameter to the <tt>mitsuba</tt> executable. The second option is to simply 
			disable these sampling strategies at the cost of reducing the 
			effectiveness of bidirectional path tracing (particularly, when rendering
			caustics). For this, set <tt>lightImage</tt> to <tt>false</tt>.
			When rendering an image of a reasonable resolution without network nodes,
			this is not a big concern, hence these strategies are enabled by default.</p>
		</descr>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
			Specifies the longest path depth in the generated output image (where <tt>-1</tt>
			corresponds to ∞). A value of 1 will only render directly visible light sources. 
			2 will lead to single-bounce (direct-only) illumination, and so on.
		</param>
		<param name="lightImage" readableName="Create light image" type="boolean" default="true">
			Include sampling strategies that connect
			paths traced from emitters directly to the camera? (i.e. what the adjoint particle tracer does)
			This improves the effectiveness of bidirectional path tracing
			but severely increases the local and remote communication 
			overhead, since large <em>light images</em> must be transferred between threads
			or over the network. See the text below for a more detailed explanation.
		</param>
		<param name="sampleDirect" readableName="Use direct sampling methods" type="boolean" default="true">
			Enable direct sampling strategies? This is a generalization of direct illumination sampling that works with both emitters
			and sensors. Usually a good idea.
		</param>
		<param name="rrDepth" readableName="Russian Roulette starting depth" type="integer" default="5" importance="1">
			Specifies the minimum path depth, after which the implementation will start to use the 
			"russian roulette" path termination criterion (set to <tt>-1</tt> to disable). 
		</param>
	</plugin>

	<plugin type="integrator" name="pssmlt" readableName="Primary Sample Space MLT" show="true"
			className="PSSMLT" extends="Integrator">
		<descr>
			Kelemen-style Metropolis Light Transport implementation. This
			integrator can operate on top of either a simple path tracer or a 
			fully-fledged bidirectional path tracer with multiple importance 
			sampling. Various optimizations are implemented, namely stratified 
			mutations, separate direct illumination, two-stage MLT, and the 
			improved weights proposed by Kelemen et al. For details, see 
			the respective parameter descriptions.
		</descr>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
			Specifies the longest path depth in the generated output image (where <tt>-1</tt>
			corresponds to ∞). A value of 1 will only render directly visible light sources. 
			2 will lead to single-bounce (direct-only) illumination, and so on.
		</param>
		<param name="separateDirect" readableName="Separate direct illumination" type="boolean" default="true">
		   Should direct illumination be handled separately? (i.e. not
		   using MLT) This is usually the right way to go, since direct
		   illumination is easily handled using more optimized rendering
		   techniques that can make use of low-discrepancy point sets.
		   This in turn lets MLT focus on the more difficult parts of the
		   light transport. On the other hand, some scenes use very
		   hard to find paths even for direct illumination, in which case
		   it may make more sense to set this property to <tt>false</tt>.
		</param>
		<param name="directSamples" readableName="Direct samples" type="integer" default="16">
		   When <tt>separateDirect</tt> is set to <tt>true</tt>, this parameter can
		   be used to specify the samples per pixel used to render the
		   direct component. Should be a power of two (otherwise, it will be
		   rounded to the next one). When set to zero or less, the
		   direct illumination component will be hidden, which is useful
		   for analyzing the component rendered by MLT.
	   </param>
	   <param name="bidirectional" readableName="Bidirectional" type="boolean" default="true"> 
		   If set to <tt>true</tt>, the MLT algorithm runs on top of a
		   bidirectional path tracer with multiple importance sampling.
		   Otherwise, the implementation reverts to a basic path tracer.
		   Generally, the bidirectional path tracer should be noticably
		   better, so it's best to this setting at its default.
		</param>
		<param name="twoStage" readableName="Two-stage MLT" type="boolean" default="false">
		   This setting can be very useful to reduce noise in dark regions
		   of the image: it activates two-stage MLT, where a nested MLT renderer
		   first creates a tiny version of the output image. In a second pass, 
		   the full version is then rendered, while making use of information 
		   about the image-space luminance distribution found in the first
		   pass. Two-stage MLT is very useful in making the noise characteristics
		   more uniform over time image -- specifically, since MLT tends to get
		   stuck in very bright regions at the cost of the remainder of the image.
		</param>
		<param name="firstStageSizeReduction" readableName="First-stage size reduction" type="integer" default="16" importance="1">
		   When running two-stage MLT, this parameter influences the size
		   of the downsampled image created in the first pass (i.e. setting this
		   to 16 means that the horizontal/vertical resolution will be 16 times
		   lower). When the two-stage process introduces noisy halos around
		   very bright image regions, it might might be good to reduce this 
		   parameter to 4 or even 1. Generally though, it should be safe to leave
		   it unchanged.
		</param>
		<param name="stratifyLargeMutations" readableName="Stratify mutations" type="boolean" default="true">
			Should the implementation try to achieve a better spread of the
			image plane pixel positions associated with paths? This is done by passing 
			stratified positions to large mutations. The default is
			<tt>true</tt>.
		</param>
		<param name="sampleDirect" readableName="Use direct illumination sampling" type="boolean" default="true">
		   Should an optimized direct illumination sampling strategy be used
		   for s=1 paths? (as opposed to plain emission sampling). Usually
		   a good idea. Note that this setting only applies when the 
		   bidirectional path tracer is used internally. The optimization
		   affects all paths, not just the ones contributing direct illumination,
		   hence it is completely independent of the <tt>separateDirect</tt>
		   parameter. 
		</param>
		<param name="workUnits" readableName="Parallel work units" type="integer" default="-1">
		   Specifies the number of parallel work units required for
		   multithreaded and network rendering. When set to <tt>-1</tt>, the 
		   amount will default to four times the number of cores. Note that
		   every additional work unit entails a significant amount of 
		   communication overhead (a full-sized floating put image must be 
		   transmitted), hence it is important to set this value as low as 
		   possible, while ensuring that there are enough units to keep all 
		   workers busy.
		</param>
		<param name="kelemenWeights" readableName="Kelemen-style weights" type="boolean" default="true">
		   Should the multiple importance sampling-based weight computation by 
		   Kelemen et al. be used? Otherwise, the implementation falls back
		   to the 'use of expectations' technique from Veach-style MLT.
		</param>
		<param name="luminanceSamples" readableName="Luminance samples" type="integer" default="100000" importance="1">
			Number of samples used to estimate the total luminance 
			received by the camera's sensor.
		</param>
		<param name="pLarge" readableName="Large step probability" type="float" default="0.3" importance="1">
		   Probability of creating large mutations in the [Kelemen et. al] 
		   MLT variant. The default is 0.3.
		</param>
		<param name="rrDepth" readableName="Russian Roulette starting depth" type="integer" default="5" importance="1">
			Specifies the minimum path depth, after which the implementation will start to use the 
			"russian roulette" path termination criterion (set to <tt>-1</tt> to disable). 
		</param>
		<param name="timeout" readableName="Timeout" type="integer" default="0" importance="1">
			If set to a nonzero value, the rendering process will automatically be stopped after this many seconds.
		</param>
	</plugin>

	<plugin type="integrator" name="mlt" readableName="Path Space MLT" show="true"
			className="MLT" extends="Integrator">
		<descr>
			Veach-style Metropolis Light Transport implementation with support for
			bidirectional mutations, lens perturbations, caustic perturbations and
			multi-chain perturbations. Several optimizations are also implemented, namely
			separate direct illumination, two-stage MLT, and importance sampling of 
			mutation strategies. For details, see the respective parameter descriptions.
		</descr>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
			Specifies the longest path depth in the generated output image (where <tt>-1</tt>
			corresponds to ∞). A value of 1 will only render directly visible light sources. 
			2 will lead to single-bounce (direct-only) illumination, and so on.
		</param>
		<param name="separateDirect" readableName="Separate direct illumination" type="boolean" default="true">
		   Should direct illumination be handled separately? (i.e. not
		   using MLT) This is usually the right way to go, since direct
		   illumination is easily handled using more optimized rendering
		   techniques that can make use of low-discrepancy point sets.
		   This in turn lets MLT focus on the more difficult parts of the
		   light transport. On the other hand, some scenes use very
		   hard to find paths even for direct illumination, in which case
		   it may make more sense to set this property to <tt>false</tt>.
		</param>
		<param name="directSamples" readableName="Direct samples" type="integer" default="16">
		   When <tt>separateDirect</tt> is set to <tt>true</tt>, this parameter can
		   be used to specify the samples per pixel used to render the
		   direct component. Should be a power of two (otherwise, it will be
		   rounded to the next one). When set to zero or less, the
		   direct illumination component will be hidden, which is useful
		   for analyzing the component rendered by MLT.
	   </param>
		<param name="twoStage" readableName="Two-stage MLT" type="boolean" default="false">
		   This setting can be very useful to reduce noise in dark regions
		   of the image: it activates two-stage MLT, where a nested MLT renderer
		   first creates a tiny version of the output image. In a second pass, 
		   the full version is then rendered, while making use of information 
		   about the image-space luminance distribution found in the first
		   pass. Two-stage MLT is very useful in making the noise characteristics
		   more uniform over time image -- specifically, since MLT tends to get
		   stuck in very bright regions at the cost of the remainder of the image.
		</param>
		<param name="firstStageSizeReduction" readableName="First-stage size reduction" type="integer" default="16" importance="1">
		   When running two-stage MLT, this parameter influences the size
		   of the downsampled image created in the first pass (i.e. setting this
		   to 16 means that the horizontal/vertical resolution will be 16 times
		   lower). When the two-stage process introduces noisy halos around
		   very bright image regions, it might might be good to reduce this 
		   parameter to 4 or even 1. Generally though, it should be safe to leave
		   it unchanged.
		</param>
		<param name="workUnits" readableName="Parallel work units" type="integer" default="-1">
		   Specifies the number of parallel work units required for
		   multithreaded and network rendering. When set to <tt>-1</tt>, the 
		   amount will default to four times the number of cores. Note that
		   every additional work unit entails a significant amount of 
		   communication overhead (a full-sized floating put image must be 
		   transmitted), hence it is important to set this value as low as 
		   possible, while ensuring that there are enough units to keep all 
		   workers busy.
		</param>
		<param name="luminanceSamples" readableName="Luminance samples" type="integer" default="100000" importance="1">
			Number of samples used to estimate the total luminance 
			received by the camera's sensor.
		</param>
		<param name="bidirectionalMutation" readableName="Bidirectional mutation" type="boolean" default="true" importance="1">
			Selectively enable/disable the bidirectional mutation
		</param>
		<param name="lensPerturbation" readableName="Lens perturbation" type="boolean" default="false" importance="1">
			Selectively enable/disable the lens perturbation
		</param>
		<param name="causticPerturbation" readableName="Caustic perturbation" type="boolean" default="false" importance="1">
			Selectively enable/disable the caustic perturbation
		</param>
		<param name="multiChainPerturbation" readableName="Multi-chain perturbation" type="boolean" default="false" importance="1">
			Selectively enable/disable the multi-chain perturbation
		</param>
		<param name="manifoldPerturbation" readableName="Manifold perturbation" type="boolean" default="false" importance="1">
			Selectively enable/disable the manifold perturbation
		</param>
		<param name="probFactor" readableName="Probability factor" type="float" default="50" importance="1">
			Manifold perturbation: probability factor ("lambda")
		</param>
		<param name="timeout" readableName="Timeout" type="integer" default="0" importance="1">
			If set to a nonzero value, the rendering process will automatically be stopped after this many seconds.
		</param>
	</plugin>

	<plugin type="integrator" name="erpt" readableName="Energy redistribution path tracing" show="true"
			className="EnergyRedistributionPathTracer" extends="Integrator">
		<descr>
			Energy redistribution path tracing as proposed by Cline et al.
		</descr>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
			Specifies the longest path depth in the generated output image (where <tt>-1</tt>
			corresponds to ∞). A value of 1 will only render directly visible light sources. 
			2 will lead to single-bounce (direct-only) illumination, and so on.
		</param>
		<param name="rrDepth" readableName="Russian Roulette starting depth" type="integer" default="5" importance="1">
			Specifies the minimum path depth, after which the implementation will start to use the 
			"russian roulette" path termination criterion (set to <tt>-1</tt> to disable). 
		</param>
		<param name="numChains" readableName="Average number of chains" type="float" default="1">
		    Specifies the number of Markov Chains that, on average, are
			started per pixel
		</param>
		<param name="maxChains" readableName="Max. number of chains" type="integer" default="0">
		    Specifies a limit for the number of chains that will be started at
			a pixel. '0' disables this option.
		</param>
		<param name="chainLength" readableName="Mutations per chain" type="integer" default="100">
			Specifies the number of mutations to be performed in each Markov Chain
		</param>
		<param name="separateDirect" readableName="Separate direct illumination" type="boolean" default="true">
		   Should direct illumination be handled separately? (i.e. not
		   using ERPT) This is usually the right way to go, since direct
		   illumination is easily handled using more optimized rendering
		   techniques that can make use of low-discrepancy point sets.
		   This in turn lets ERPT focus on the more difficult parts of the
		   light transport. On the other hand, some scenes use very
		   hard to find paths even for direct illumination, in which case
		   it may make more sense to set this property to <tt>false</tt>.
	   </param>
		<param name="directSamples" readableName="Direct samples" type="integer" default="16">
		   When <tt>separateDirect</tt> is set to <tt>true</tt>, this parameter can
		   be used to specify the samples per pixel used to render the
		   direct component. Should be a power of two (otherwise, it will be
		   rounded to the next one). When set to zero or less, the
		   direct illumination component will be hidden, which is useful
		   for analyzing the component rendered by MLT.
	   </param>
		<param name="luminanceSamples" readableName="Luminance samples" type="integer" default="15000" importance="1">
			Number of samples used to estimate the average contribution of a
			single sample. Usually, this parameter can be left untouched.
		</param>
		<param name="bidirectionalMutation" readableName="Bidirectional mutation" type="boolean" default="false" importance="1">
			Selectively enable/disable the bidirectional mutation
		</param>
		<param name="lensPerturbation" readableName="Lens perturbation" type="boolean" default="false" importance="1">
			Selectively enable/disable the lens perturbation
		</param>
		<param name="causticPerturbation" readableName="Caustic perturbation" type="boolean" default="false" importance="1">
			Selectively enable/disable the caustic perturbation
		</param>
		<param name="multiChainPerturbation" readableName="Multi-chain perturbation" type="boolean" default="false" importance="1">
			Selectively enable/disable the multi-chain perturbation
		</param>
		<param name="manifoldPerturbation" readableName="Manifold perturbation" type="boolean" default="true" importance="1">
			Selectively enable/disable the manifold perturbation
		</param>
		<param name="probFactor" readableName="Probability factor" type="float" default="50" importance="1">
			Manifold perturbation: probability factor ("lambda")
		</param>
	</plugin>
	<plugin type="medium" className="Medium" abstract="true">
		<shortDescr>Base class of all participating media</shortDescr>
		<descr>
			Base class of all participating media -- By default, the parameters are set to 
			the skim milk data from "A Practical Model for Subsurface scattering" (Jensen et al.)
		</descr>
		<param name="sigmaS" type="spectrum" default="0.7, 1.22, 1.9">Scattering coefficient</param>
		<param name="sigmaT" type="spectrum" default="0.0014, 0.0025, 0.0142">Absorption coefficient</param>
		<param name="sizeMultiplier" type="float" default="1">Scattering/absorption coefficient multiplier - can be used to convert these to world-space units.</param>
		<child type="phase" count="1">
			Specifies the phase function of the medium. If none is specified,
			the default (<tt>isotropic</tt>) is chosen.
		</child>
	</plugin>

	<plugin type="medium" name="homogeneous" className="HomogeneousMedium" extends="Medium">
		<shortDescr>Homogeneous participating medium</shortDescr>
		<descr>
			Homogeneous participating medium. An arbitrary (manifold) shape
			must be specified as a child object.
		</descr>
		<child type="shape" count="1">Specifies the shape of the medium</child>
	</plugin>

	<plugin type="medium" name="heterogeneous" className="HeterogeneousMedium" extends="Medium">
		<shortDescr>Heterogeneous participating medium</shortDescr>
		<descr>
			Heterogeneous medium class using trilinear interpolation, 
			Simpson quadrature and one of several possible sampling
			strategies. Data files have to be provided in an ASCII
			format as follows:<br/>
			<ul>
				<li> The first three numbers determine the X,Y and Z resolution,
				each of which has to be larger than 2.</li>
				<li>The next six numbers determine the minimum X, Y and Z
				as well as the maximum X, Y and Z values of the enclosing
				axis-aligned bounding box.</li>
				<li>Afterwards, (xres*yres*zres) density samples follow in 
				XYZ order, (e.g. the second entry has coordinate x=2)</li>
			</ul>
		</descr>

		<param name="filename" type="string">File containing sampled volume densities</param>

		<param name="strategy" type="string" default="standard">
			Specifies the used strategy - the four choices are:
			<ul>
				<li><tt>standard</tt>: generate a 'desired' accumulated density by sampling an
					exponentially distributed random variable. Afterwards, try to find the
					distance, at which this much density has been accumulated. Here, the
					composite Simpson's rule is used to integrate density along the ray.</li>
				<li><tt>coleman</tt>: Sampling technique by [Coleman et al., 1967]. Only for media with
					a wavelength-independent extinction coefficient.</li>
				<li><tt>uniform</tt>: Naive variant for verification purposes: uniformly 
					sample a distance along the ray segment, which intersects the volume</li>
				<li><tt>double</tt>: Double integral approach - stupid and slow, but it also works..</li>
			</ul>
		</param>

		<param name="stepSizeFactor" type="float" default="1">
			While integrating density along a ray, approximately one sample
			per voxel is taken - that number can be changed here
		</param>

		<param name="sigma" type="float" default="min(sigmaA+sigmaS)">
			Can be used to override the extinction coefficient used to sample distances 
			in the in-scatter line integral. By default, the smallest spectral sample of 
			<tt>sigmaA+sigmaT</tt> is used.
		</param>
	</plugin>


	<plugin type="phase" name="isotropic" className="IsotropicPhaseFunction" extends="PhaseFunction">
		<shortDescr>Isotropic phase function</shortDescr>
		<descr>
			Basic isotropic phase function
		</descr>
	</plugin>

	<plugin type="phase" name="hg" className="HGPhaseFunction" extends="PhaseFunction">
		<shortDescr>Henyey-Greenstein phase function</shortDescr>
		<descr>
			Phase function by Henyey and Greenstein (1941). Parameterizable
			from backward- through isotropic- to forward scattering.
		</descr>
		<param name="g" type="float" default="0.8">
			Asymmetry parameter of the Henyey-Greenstein phase function. Must
			lie in [-1, 1] where &gt;0 is forward scattering and &lt;0 is backward
			scattering.
		</param>
	</plugin>

	<plugin type="luminaire" className="Luminaire" abstract="true">
		<shortDescr>Abstract luminaire</shortDescr>
		<descr>Abstract implementation of a luminaire. Supports emission and shadow ray sampling and computes related probabilities.</descr>
		<param name="toWorld" type="transform" default="identity">Affine luminaire space to world space transformation</param>
	</plugin>

	<plugin type="luminaire" name="area" className="AreaLuminaire" extends="Luminaire">
		<shortDescr>Lambertian area luminaire</shortDescr>
		<descr>
			Lambertian area light source - can be attached to an arbitrary shape
			contained inside the scene. Shadow rays are generally sampled
			uniformly with respect to surface area, which may lead to high
			variance (e.g. many of the generated samples are facing away
			from the point to be shaded). 
			When the shape in question is a sphere, rays are sampled uniformly 
			wrt. solid angle, which significantly reduces the variance.
			Thus, spheres are recommended whenever there is some flexibility 
			in choosing the luminaire shape.
		</descr>
		<param name="intensity" type="spectrum" default="1">Intensity of the luminaire</param>
	</plugin>

	<plugin type="luminaire" name="collimated" className="CollimatedBeamLuminaire" extends="Luminaire">
		<shortDescr>Collimated beam luminaire</shortDescr>
		<descr>Collimated beam with a configurable thickness. Points from <tt>(0,0,0)-&gt;(0,0,1)</tt> by default - 
			use the <tt>toWorld</tt> parameter to change this. 
		</descr>
		<param name="radius" type="float" default="0.01">World-space beam radius</param>
		<param name="intensity" type="spectrum" default="power/surfaceArea">Intensity of the luminaire. 
			Specify only one of <tt>intensity</tt> and <tt>power.</tt></param>
		<param name="power" type="spectrum" default="1">Power of the luminaire. 
			Specify only one of <tt>intensity</tt> and <tt>power.</tt></param>
	</plugin>

	<plugin type="luminaire" name="point" className="PointLuminaire" extends="Luminaire">
		<shortDescr>Isotropic point source</shortDescr>
		<descr>Positioned at <tt>(0,0,0)</tt> by default - use the
			<tt>toWorld</tt> parameter to change this.</descr>
		<param name="intensity" type="spectrum" default="1">Intensity of the luminaire</param>
	</plugin>

	<plugin type="luminaire" name="spot" className="SpotLuminaire" extends="Luminaire">
		<shortDescr>VRML SpotLight-equivalent luminaire</shortDescr>
		<descr>
			In its local coordinate system, the spot light is positioned at the origin and points into the positive Z
			direction. Its intensity linearly ramps up between <tt>cutoffAngle</tt>
			and <tt>beamWidth</tt>, after which it remains at the maximum value.
		</descr>
		<param name="intensity" type="spectrum" default="1">Intensity of the luminaire</param>
		<param name="cutoffAngle" type="float" default="20">Cutoff angle in degrees</param>
		<param name="beamWidth" type="float" default="cutoffAngle * 3/4">Beam width in degrees</param>
	</plugin>

	<plugin type="luminaire" name="constant" className="ConstantLuminaire" extends="Luminaire">
		<shortDescr>Constant background luminaire</shortDescr>
		<descr>Simulates a diffuse, infinitely far-away emitter</descr>
		<param name="intensity" type="spectrum" default="1">Intensity of the luminaire</param>
	</plugin>

	<plugin type="luminaire" name="envmap" className="EnvMapLuminaire" extends="Luminaire">
		<shortDescr>Environment map luminaire</shortDescr>
		<descr>
			Basic environment map implementation without importance sampling.
			Uses the scene's bounding sphere to simulate an infinitely far-away
			light source. Expects an EXR image in latitude-longitude (equirectangular) format.
		</descr>
		<param name="intensity" type="spectrum" default="1">Intensity of the luminaire</param>
	</plugin>

	<plugin type="camera" className="Camera" abstract="true">
		<shortDescr>Camera base class</shortDescr>
		<descr>
			A camera turns a sample on the image plane into a 3D ray. 
			For this, it requires two supporting objects: a <tt>Sampler</tt> and a <tt>Film</tt> instance.
		</descr>
		<param name="toWorld" type="transform" default="identity">Affine camera space to world space transformation</param>
	</plugin>
 
	<plugin type="camera" className="PinholeCamera" abstract="true" extends="Camera">
		<shortDescr>Pinhole camera base class</shortDescr>
		<descr>
			Provides solid angle computation
			routines useful for importance-based integrators.
		</descr>
		<param name="fov" type="float" default="90">Field of view of the camera (in degrees)</param>
		<param name="mapSmallerSide" type="boolean" default="true">Specifies which side of the image plane should cover the field of view specified in the <tt>fov</tt> parameter</param>
	</plugin>

	<plugin type="camera" name="perspective" className="PerspectiveCamera" extends="PinholeCamera">
		<shortDescr>Perspective camera model</shortDescr>
		<descr>
			Depth of field can optionally be activated by specifying both focal 
			distance and lens radius (uses a thin lens approximation)
		</descr>
		<param name="focalDistance" type="float" default="0">Distance to the focal plane</param>
		<param name="lensRadius" type="float" default="0">World-space lens radius</param>
		<param name="nearClip" type="float" default="1e-2">Near clipping plane distance</param>
		<param name="farClip" type="float" default="1e4">Far clipping plane distance</param>
	</plugin>

	<plugin type="camera" name="orthographic" className="OrthographicCamera" extends="Camera">
		<shortDescr>Orthographic camera model</shortDescr>
		<descr>
			Simple orthographic camera model
		</descr>
		<param name="nearClip" type="float" default="1e-2">Near clipping plane distance</param>
		<param name="farClip" type="float" default="1e4">Far clipping plane distance</param>
		<param name="mapSmallerSide" type="boolean" default="true">Specifies which side of the image plane 
			maps to normalized device coordinates in <tt>[0,1]</tt>
		</param>
	</plugin>
	
	<plugin type="film" className="Film" abstract="true">
		<shortDescr>Abstract Film base class</shortDescr>
		<descr>Used to store samples generated by an Integrator.</descr>
		<param name="width" type="integer" default="512">Horizontal sensor resolution in pixels</param>
		<param name="height" type="integer" default="512">Vertical sensor resolution in pixels</param>
		<param name="cropOffsetX" type="integer" default="0">Horizontal pixel position of the crop window relative to the upper left corner</param>
		<param name="cropOffsetY" type="integer" default="0">Vertical pixel position of the crop window relative to the upper left corner</param>
		<param name="cropWidth" type="integer" default="width">Width of the crop window in pixels</param>
		<param name="cropWeight" type="integer" default="height">Height of the crop window in pixels</param>
		<param name="highQualityEdges" type="boolean" default="false">
			If set to true, regions slightly outside of the film plane will also be sampled, which
			improves the image quality at the edges especially with large reconstruction filters.
		</param>
	</plugin>

	<plugin type="film" name="hdrfilm" className="HDRFilm" extends="Film">
		<shortDescr>High dynamic-range film</shortDescr>
		<descr>
			Simple film implementation, which stores the captured image
			as an RGBA-based high dynamic-range EXR file.
			No gamma correction is applied and spectral radiance values
			are converted to linear RGB using the CIE 1931 XYZ color matching 
			functions and ITU-R Rec. BT.709
		</descr>
		<param name="alpha" type="boolean" default="true">Should an alpha channel be added to the output image?</param>
		<param name="banner" type="boolean" default="true">Should a program logo be added to the output image?</param>
	</plugin>

	<plugin type="film" name="ldrfilm" className="LDRFilm" extends="Film">
		<shortDescr>PNG low dynamic-range film</shortDescr>
		<descr>
			Simple film implementation, which stores the captured image
			as an RGBA-based low dynamic-range PNG file with gamma correction.
			Spectral radiance values are converted to linear RGB using 
			the CIE 1931 XYZ color matching functions and ITU-R Rec. BT.709
		</descr>
		<param name="alpha" type="boolean" default="true">Should an alpha channel be added to the output image?</param>
		<param name="bpp" type="integer" default="24/32, dep. on alpha">Bits per pixel including alpha (must be 8, 16, 24 or 32)</param>
		<param name="gamma" type="float" default="-1">Gamma value for the correction. Negative values switch to sRGB</param>
	</plugin>

	<plugin type="film" name="mfilm" className="MFilm" extends="Film">
		<shortDescr>MATLAB film</shortDescr>
		<descr>
			Debugging film, which dumps raw luminance values as a 2D array in
			MATLAB M-file format. When test case mode is active, the film writes 
			a triple (luminance, variance, sample count) for every pixel.
		</descr>
		<param name="spectra" type="boolean" default="false">Should all spectral samples be exported? In this case, 
			each pixel will generate several numbers (matching the configured discretization of the color spectrum).
			By default, Mitsuba exports the luminances found using the CIE XYZ color matching curves.
		</param>
	</plugin>

	<plugin type="rfilter" readableName="Box filter" name="box" show="true" className="BoxFilter" extends="ReconstructionFilter">
		<descr>Box filter: the fastest, but also about the worst possible 
			reconstruction filter, since it is extremely prone to aliasing. 
			It is included mainly for completeness, though some rare situations
			may warrant its use.</descr>
	</plugin>

	<plugin type="rfilter" readableName="Tent filter" name="tent" show="true" className="TentFilter" extends="ReconstructionFilter">
		<descr>
			Simple tent, or triangle filter. This reconstruction filter never
			suffers from ringing and usually causes less aliasing than a naive 
			box filter. When rendering scenes with sharp brightness discontinuities,
			this may be useful; otherwise, negative-lobed filters will be preferable
			(e.g. Mitchell-Netravali or Lanczos Sinc)
		</descr>
	</plugin>

	<plugin type="rfilter" readableName="Gaussian filter" name="gaussian" show="true" className="GaussianFilter" extends="ReconstructionFilter">
		<descr>
			This is a windowed Gaussian filter with configurable standard deviation.
			It produces pleasing results and never suffers from ringing, but may 
			occasionally introduce too much blurring.
			When no reconstruction filter is explicitly requested, this is the default
			choice in Mitsuba.
		</descr>
		<param name="stddev" readableName="Standard deviation" type="float" default=".5">Standard deviation of the Gaussian</param>
	</plugin>

	<plugin type="rfilter" readableName="Mitchell-Netravali filter" name="mitchell" show="true" className="MitchellNetravaliFilter" extends="ReconstructionFilter">
		<descr>
			Separable cubic spline reconstruction filter by Mitchell and Netravali.
			This is often a good compromise between sharpness and ringing.
			
			The plugin has two <tt>float</tt>-valued parameters named <tt>B</tt> and <tt>C</tt> that 
			correspond to the two parameters in the original research paper. By default, these
			are set to the recommended value of 1/3, but can be tweaked if desired.
		</descr>
		<param name="B" readableName="B parameter" type="float" default="0.33333">B parameter from the paper</param>
		<param name="C" readableName="C parameter" type="float" default="0.33333">C parameter from the paper</param>
	</plugin>

	<plugin type="rfilter" readableName="Catmull-Rom filter" name="catmullrom" show="true" className="CatmullRomFilter" extends="ReconstrutionFilter">
		<descr>
			This is a special version of the Mitchell-Netravali filter that has the 
			constants <tt>B</tt> and <tt>C</tt> adjusted to produce higher sharpness at the
			cost of increased susceptibility to ringing.
		</descr>
	</plugin>

	<plugin type="rfilter" readableName="Lanczos Sinc filter" name="lanczos" show="true" className="LanczosSincFilter" extends="ReconstructionFilter">
		<descr>
			<p>This is a windowed version of the theoretically optimal low-pass filter.
			It is generally one of the best available filters in terms of producing sharp 
			high-quality output. Its main disadvantage is that it produces strong ringing around 
			discontinuities, which can become a serious problem when rendering bright objects 
			with sharp edges (for instance, a directly visible light source will have black 
			fringing artifacts around it). 
			This is also the computationally slowest reconstruction filter.</p>

			<p>This plugin has an <tt>integer</tt>-valued parameter named <tt>lobes</tt>, that
			sets the desired number of filter side-lobes. The higher, the closer
			the filter will approximate an optimal low-pass filter, but this also
			increases the susceptibility to ringing. Values of 2 or 3 are common (3 is the default).</p>
		</descr>
		<param name="lobes" readableName="Number of lobes" type="integer" default="3">Number of filter lobes</param>
	</plugin>

	<plugin type="sampler" name="independent" readableName="Independent sampler" show="true" className="IndependentSampler" extends="Sampler">
		<descr>
			<p>The independent sampler produces a stream of independent and uniformly
			distributed pseudorandom numbers. Internally, it relies on a fast SIMD version
			of the Mersenne Twister random number generator.</p>
 
			<p>This is the most basic sample generator; because no precautions are taken to avoid 
			sample clumping, images produced using this plugin will usually take longer to converge.
			In theory, this sampler is initialized using a deterministic procedure, which means
			that subsequent runs of Mitsuba should create the same image. In practice, when 
			rendering with multiple threads and/or machines, this is not true anymore, since the 
			ordering of samples is influenced by the operating system scheduler.</p>

			<p>Note that the Metropolis-type integrators implemented in Mitsuba are incompatible with
			the more sophisticated sample generators shown in this section. They <em>require</em> this 
			specific sampler and refuse to work otherwise.</p>
		</descr>	
		<param name="sampleCount" readableName="Samples per pixel" type="integer" default="4">Number of samples per pixel</param>
	</plugin>

	<plugin type="sampler" name="stratified" readableName="Stratified sampler" show="true" className="StratifiedSampler" extends="Sampler">
		<descr>
			<p>The stratified sample generator divides the domain into a discrete number
			of strata and produces a sample within each one of them. This generally leads to less 
			sample clumping when compared to the independent sampler, as well as better 
			convergence. Due to internal storage costs, stratified samples are only provided up to a 
			certain dimension, after which independent sampling takes over.</p>
 
			<p>Like the independent sampler, multicore and network renderings
			will generally produce different images in subsequent runs due to the nondeterminism
			introduced by the operating system scheduler.</p>
		</descr>
		<param name="sampleCount" readableName="Samples per pixel" type="integer" default="4">
			Number of samples per pixel; should be a perfect square (e.g. 1, 4, 9, 16, 25, etc.), or it will be rounded up to the next one
		</param>
		<param name="dimension" readableName="Effective dimension" type="integer" default="4">
			Effective dimension, up to which stratified samples are provided. The
			number here is to be interpreted as the number of subsequent 1D or 2D sample 
			requests that can be satisfied using "good" samples. Higher high values 
			increase both storage and computational costs.
		</param>
	</plugin>

	<plugin type="sampler" name="ldsampler" readableName="Low discrepancy sampler" show="true" className="LowDiscrepancySampler" extends="Sampler">
		<descr>
			<p>This plugin implements a simple hybrid sampler that combines aspects of a Quasi-Monte 
			Carlo sequence with a pseudorandom number generator based on a technique proposed 
			by Kollig and Keller.
			It is a good and fast general-purpose sample generator and therefore chosen as 
			the default option in Mitsuba. Some of the QMC samplers in the following pages can generate
			even better distributed samples, but this comes at a higher cost in terms of performance.</p>
 
			<p>Roughly, the idea of this sampler is that all of the individual 2D sample dimensions are 
			first filled using the same (0, 2)-sequence, which is then randomly scrambled and permuted 
			using numbers generated by a Mersenne Twister pseudorandom number generator 
			Note that due to internal storage costs, low discrepancy samples are only provided 
			up to a certain dimension, after which independent sampling takes over.
			The name of this plugin stems from the fact that (0, 2) sequences minimize the so-called 
			<em>star disrepancy</em>, which is a quality criterion on their spatial distribution. By 
			now, the name has become slightly misleading since there are other samplers in Mitsuba
			that just as much try to minimize discrepancy, namely the Sobol and Halton plugins.</p>
 
			<p>Like the independent sampler, multicore and network renderings
			will generally produce different images in subsequent runs due to the nondeterminism
			introduced by the operating system scheduler.</p>
		</descr>
		<param name="sampleCount" readableName="Samples per pixel" type="integer" default="4">
			Number of samples per pixel; should be a power of two
			(e.g. 1, 2, 4, 8, 16, etc.), or it will be rounded up to the next one 
		</param>
		<param name="dimension" readableName="Effective dimension" type="integer" default="4">
			Effective dimension, up to which low discrepancy samples are provided. The
			number here is to be interpreted as the number of subsequent 1D or 2D sample 
			requests that can be satisfied using "good" samples. Higher high values 
			increase both storage and computational costs.
		</param>
	</plugin>

	<plugin type="sampler" name="hammersley" readableName="Hammersley QMC sampler" show="true" className="HammersleySequence" extends="Sampler">
		<descr>
			<p>This plugin implements a Quasi-Monte Carlo (QMC) sample generator based on the
			Hammersley sequence. QMC number sequences are designed to reduce sample clumping
			across integration dimensions, which can lead to a higher order of 
			convergence in renderings. Because of the deterministic character of the samples,
			errors will manifest as grid or moiré patterns rather than random noise, but
			these diminish as the number of samples is increased.</p>
 
			<p>The Hammerlsey sequence is closely related to the Halton sequence and yields a very
			high quality point set that is slightly more regular (and has lower discrepancy),
			especially in the first few dimensions. As is the case with the Halton sequence,
			the points should be scrambled to reduce patterns that manifest due due to correlations
			in higher dimensions. </p>

			<p>Note that this sampler will cause odd-looking intermediate results when combined with rendering 
			techniques that trace paths starting at light source (e.g. the adjoint particle tracer)—these vanish 
			by the time the rendering process finishes.</p>
		</descr>
		<param name="sampleCount" readableName="Samples per pixel" type="integer" default="4">Number of generated samples / samples per pixel</param>
		<param name="scramble" readableName="Scramble value" type="integer" default="-1">
			This plugin can operate in one of three scrambling modes:
			<ul>
				<li>When set to <tt>0</tt>, the implementation will provide the standard Hammersley sequence.</li>

				<li>When set to <tt>-1</tt>, the implementation will compute
				a scrambled variant of the Hammersley sequence based on permutations by 
				Faure, which has better equidistribution properties
				in high dimensions.</li>

				<li>
				When set to a value greater than one, a random permutation is chosen based
				on this number. This is useful to break up temporally coherent noise when rendering
				the frames of an animation—in this case, simply set the parameter to the current frame index.
				</li>
			</ul>
			Default: <tt>-1</tt>, i.e. use the Faure permutations. Note that permutations rely on a 
			precomputed table that consumes approximately 7 MiB of additional memory at run time. 
		</param>
	</plugin>

	<plugin type="sampler" name="halton" readableName="Halton QMC sampler" show="true" className="HaltonSequence" extends="Sampler">
		<descr>
			<p>This plugin implements a Quasi-Monte Carlo (QMC) sample generator based on the
			Halton sequence. QMC number sequences are designed to reduce sample clumping
			across integration dimensions, which can lead to a higher order of 
			convergence in renderings. Because of the deterministic character of the samples,
			errors will manifest as grid or moiré patterns rather than random noise, but
			these diminish as the number of samples is increased.</p>
 
			<p>The Halton sequence in particular provides a very high quality point set that unfortunately 
			becomes increasingly correlated in higher dimensions. To ameliorate this problem, the Halton 
			points are usually combined with a scrambling permutation, and this is also the default.
			Because everything that happens inside this sampler is completely deterministic and 
			independent of operating system scheduling behavior, subsequent runs of Mitsuba will always 
			compute the same image, and this even holds when rendering with multiple threads 
			and/or machines.</p>

			<p>By default, the implementation provides a scrambled variant of the Halton sequence based 
			on permutations by Faure that has better equidistribution properties
			in high dimensions, but this can be changed using the <tt>scramble</tt> parameter.
			Internally, the plugin uses a table of prime numbers to provide elements 
			of the Halton sequence up to a dimension of 1024. Because of this upper bound,
			the maximum path depth of the integrator must be limited (e.g. to 100), or
			rendering might fail with the following error message: <tt>Lookup dimension 
			exceeds the prime number table size! You may have to reduce the 'maxDepth' 
			parameter of your integrator</tt>.</p>
		</descr>
		<param name="sampleCount" readableName="Samples per pixel" type="integer" default="4">Number of generated samples / samples per pixel</param>
		<param name="scramble" readableName="Scramble value" type="integer" default="-1">
			This plugin can operate in one of three scrambling modes:
			<ul>
				<li>When set to <tt>0</tt>, the implementation will provide the standard Hammersley sequence.</li>

				<li>When set to <tt>-1</tt>, the implementation will compute
				a scrambled variant of the Hammersley sequence based on permutations by 
				Faure, which has better equidistribution properties
				in high dimensions.</li>

				<li>
				When set to a value greater than one, a random permutation is chosen based
				on this number. This is useful to break up temporally coherent noise when rendering
				the frames of an animation—in this case, simply set the parameter to the current frame index.
				</li>
			</ul>
			Default: <tt>-1</tt>, i.e. use the Faure permutations. Note that permutations rely on a 
			precomputed table that consumes approximately 7 MiB of additional memory at run time. 
		</param>
	</plugin>


	<plugin type="sampler" name="sobol" readableName="Sobol QMC sampler" show="true" className="SobolSampler" extends="Sampler">
		<descr>
			<p>This plugin implements a Quasi-Monte Carlo (QMC) sample generator based on the
			Sobol sequence. QMC number sequences are designed to reduce sample clumping
			across integration dimensions, which can lead to a higher order of 
			convergence in renderings. Because of the deterministic character of the samples,
			errors will manifest as grid or moiré patterns rather than random noise, but
			these diminish as the number of samples is increased. </p>

			<p>The Sobol sequence in particular provides a relatively good point set that can
			be computed extremely efficiently. One downside is the susceptibility to pattern artifacts
			in the generated image. To minimize these artifacts, it is advisable to use
			a number of samples per pixel that is a power of two.</p>

			<p>Because everything that happens inside this sampler is completely 
			deterministic and independent of operating system scheduling behavior, subsequent 
			runs of Mitsuba will always compute the same image, and this even holds when rendering 
			with multiple threads and/or machines.</p>

			<p>The plugin relies on a fast implementation of the Sobol sequence by Leonhard
			Grünschloß using direction numbers provided by Joe and Kuo.
			These direction numbers are given up to a dimension of 1024. Because of this 
			upper bound, the maximum path depth of the integrator must be limited (e.g. to 100), or
			rendering might fail with the following error message: <tt>Lookup dimension 
			exceeds the direction number table size! You may have to reduce the 'maxDepth' 
			parameter of your integrator</tt>.</p>
		</descr>
		<param name="sampleCount" readableName="Samples per pixel" type="integer" default="4">Number of samples per pixel</param>
		<param name="scramble" readableName="Scramble value" type="integer" default="0">
			Scramble value that can be used to break up temporally coherent 
			noise patterns. For stills, this parameter is irrelevant. When rendering an animation,
			simply set it to the current frame index.
		</param>
	</plugin>
</documentation>
